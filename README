The ZX Spectrum Community                                  Justin Forest
Public Documentation                                        October 2004

                          ZX Assembler Toolkit

Table of Contents

   1. Preamble.
   2. The package.
      1. The translator (zat).
         1. Expression evaluation and passes.
	 2. Assembler syntax.
	    1. CPU.
	    2. ORG.
	    3. SEGMENT.
	    4. ENT.
	    5. DEFB.
	    6. DEFW.
	    7. EQU.
	    8. INSERT.
      2. The preprocessor (zatp).
   A. Distribution.
   B. Contact information.


1. Preamble.

   The times when natively hosted developement for ZX Spectrum was
   acceptable are long gone.  The days when ZX Spectrum was fine for
   developing Z80 based integrated peripherials are also in the past.
   With multi-GHz computers at hand, developers want to utilize this
   power for cross-developement.  Zat is a toolkit for such people.


2. The package.

   Zat currently consists of two main parts: the translator, which
   assembles programs, and the preprocessor, which expands macros
   and otherwise makes the source code easier to process by the
   translator.


2.1. The translator (zat).

   The translator is the program that assembles the source code.
   It accepts multiple input source files which are, however, treated
   as if they were concatenated; the translator does not include
   source files, this is one of the preprocessor's tasks.  It does,
   however, perform binary inclusions.

2.1.1. Expression evaluation and passes.

   Zat is a single pass translator.  Expressions which can not be
   evaluated at the time they are parsed are delayed and undefined
   bytes of data are emitted.  When the unconditional part of the
   source code is assembled, the translator repeatedly goes through
   the list of delayed expressions, reevaluates them and reemits the
   code, until either the list of expressions becomes empty or there
   are expressions that can not be evaluated (undefined labels, etc).
   The latter is a fatal error.

   The only price you pay for the speed of translation is obvious:
   expressions which directly affect the size or the position of the
   emitted machine code must be immediately evaluated (this currently
   applies to arguments of instructions ORG and ENT).  However, the
   practice of using this type ofexpressions in this context is
   believed to be error-prone.

   Each expression can contain unlimited number of numeric constants,
   characters, labels and arythmetic operators such as +, -, * and /.
   There is a special label $, which corresponds to the current
   instruction address.

   Numeric constants can be defined in either decimal, hexadecimal or
   binary form, eg:

     Decimal:     1234
     Hexadecimal: 1234h
                  0x1234
     Binary:      0001b

   Characters are written in single quotation marks (or "apostrophs"),
   their ASCII codes can be used in expressions as any other numbers.

2.1.2. Assembler syntax.

   Zat itself does not know anything about any CPU instructiton set.
   The instructions supported by each CPU are read from a text file,
   the CPU definition table.  Zat directly supports a limited set
   of instructions that affect the process of generating the machine
   code.  These CPU-independent instructions are described below in
   this chapter.

   Each line of the source code has the following form:

   [label:] [instruction [arguments]] [;comment]

   Each part of the line is optional.  One line can only contain
   one instruction and one label.  The comment ends with the current
   line; block comments are currently not supported and such support
   is not currently planned (very untypical for the assembly language).

   Labels can contain latin letters, digits and underscores.  The
   length of the label is unlimited, however, it is recommended not
   to exceed 10 characters.  Labels that look like numeric constants
   lead to a fatal error and abort the translation.

   Zat does not support extensions like a list of arguments that would
   be expanded to several commands, each with one argument (like some
   Z80 assemblers do with PUSH and POP, for example).  Please use the
   canonical syntax.


2.1.2.1. CPU.

   This instruction tells zat to load an instruction set definition
   table.  If the table is already active, nothing happens; otherwise
   the current CPU definition is erased and new instructions are read.

   Only one CPU definition can be active at a time.  You typically
   want to specify the CPU in the beginning of the source file.  It
   is possible to change it later, however, there barely is a use
   for this approach.

   The default CPU type is Z80.


2.1.2.2. ORG.

   Syntax: ORG <address> [, <phase>]

   This instruction changes the base address at which the following
   machine code originates.  The default base address is zero, which
   means that the machine code will be placed at the beginning of
   memory.

   The optional phase parameter defines the address at which the
   machine code will actually be running.  This is useful if you
   write the code that will later be relocated by your own program.
   The effect of the phase parameter can be turned off by "ORG $".

   Zat allows multiple ORG instructions to coexist.

   Each ORG command starts a new block of machine code.  Zat makes
   sure that the block do not overlap; if this happens, an error is
   reported and the translation aborts.  This does not apply to the
   phase address, however.


2.1.2.3. SEGMENT.

   Syntax: SEGMENT <name>

   This instruction switches to a different segment of memory.
   A segment is typically an alternative slice of memory of the
   standard size (configured by the command line).  The purpose of
   segments can be different with different forms of output.

   The effect of the ORG instruction is normally bound to the current
   segment.  When raw blocks of machine code are saved as a result
   of the translation, you may have as many segments as you wish (like,
   nothing but the common sense can stop you from assembling several
   different programs into different segments using a single source
   file).  However, some forms of output may collapse some segments
   which may cause blocks of machine code to overlap.

   Read about the particular form of output to learn about the
   full effect of this instruction.


2.1.2.4. ENT.

   Syntax: ENT <address>

   This instruction defines the entry point of the program.  There
   can be only one entry point, multiple uses of this instructions
   result in a fatal error that aborts the translation.

   This instruction is only useful in conjunction with snapshot
   type output (see below); it has no effect if the output is written
   as blocks of raw machine code.


2.1.2.5. DEFB.

   Syntax: DEFB <expression> [, <expression> [, ...]]

   This instruction emits a single byte of data.  If the value of
   the argument is less than -128 or greater than 255, an error is
   reported and the translation aborts.

   Multiple arguments may be separated by commas.  Each argument's
   evaluation may be delayed.

   Each argument can be a quoted string, in which case each character
   is emitted as a single unit (a byte for DEFB).


2.1.2.6. DEFW.

   Syntax: DEFW <expression> [, <expression> [, ...]]

   This instruction emits two bytes of data.  If the value of the
   argument is less than -32768 or greater than 65535, an error is
   reported and the translation aborts.

   Multiple arguments may be separated by commas.  Each argument's
   evaluation may be delayed.


2.1.2.7. EQU.

   Syntax: EQU <name>

   This instruction assigns a value to a label.  Normally, labels
   carry the current translation address; with this instruction
   a label can be assigned a different value.


2.1.2.8. INSERT.

   Syntax: INSERT <filename>


2.2. The preprocessor (zatp).

   This program's purpose is to make the source code easier to
   parse.  It does the following:

   1. Process all INCLUDE instructions (see below).
   2. Optionally strip extraneous data (spaces and comments).
   3. Convert local labels to the global ones by adding a #X suffix,
      where X is a random decimal number.


A. Distribution.


B. Contact information.
